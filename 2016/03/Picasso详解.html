<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>蒋黎的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="静思、勤写、乐享">
    <link href="/images/favicon.png" rel="shortcut icon">
    <script src="/js/jquery.min.js"></script>
    <script src="/js/bootstrap.min.js"></script>
    <link href="/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/css/theme.css" rel="stylesheet" type="text/css">
    <link href="/css/syntax.css" rel="stylesheet" type="text/css">
</head>

<body>

<div class="container-fluid">
    <div class="row-fluid">
        <div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                  <span class="sr-only">Toggle Navigation</span>
                  <span class="icon-bar"></span>
                  <span class="icon-bar"></span>
                  <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/" style="padding:5px;">
                  <img src="/images/self.png" style="width: 40px;height: 40px;" alt="蒋黎的博客" />
                </a>
              </div>
              <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li><a href="/">主页</a></li>
                    <li><a href="/archive.html">文章列表</a></li>
                    <!-- <li><a href="/about.html">关于</a></li> -->
                    <li class="visible-xs-block"><a href="/links.html">相关链接</a></li>
                </ul>
              </div>
        </div>
    </div>
</div>


<div class="container container-left">
    <div class="row">
        <div class="col-md-9">
          <div class="article" style="border-right: 1px solid #eee;border-left: 1px solid #eee;">
            <div class="well">
                <h1 style="margin-bottom: 20px;"><a href="/2016/03/Picasso%E8%AF%A6%E8%A7%A3">Picasso详解</a></h1>
            
                <p class="author">
                  <a href="#disqus_thread" data-disqus-identifier="2016-03-picasso-e8-af-a6-e8-a7-a3">查看评论</a>
                </p>
            
            <div class="post-content">
            <p><strong>摘要</strong>：本文基于<a href="https://github.com/square/picasso"><code class="highlighter-rouge">Picasso</code></a>的源码来分析图片加载及缓存的流程。
<!-- excerpt split --></p>

<hr />

<p><strong>文章原创，允许转载，转载请注明出处。</strong></p>

<hr />

<h3 id="section">一. 概述</h3>
<p><a href="https://github.com/square/picasso"><code class="highlighter-rouge">Picasso</code></a>是<a href="https://github.com/square"><code class="highlighter-rouge">Square</code></a>出品的一个非常精简的图片加载及缓存库，其主要特点包括：</p>

<ul>
  <li>易写易读的流式编程风格</li>
  <li>中心事件分发器</li>
  <li>拦截器式图片加载流</li>
  <li>链式图片转换流</li>
  <li>无效请求清除器</li>
  <li>内存与磁盘双缓存策略</li>
</ul>

<p>应用<a href="https://github.com/square/picasso"><code class="highlighter-rouge">Picasso</code></a>加载图片的主流程如下（<a href="/images/picasso.jpg">查看原图</a>）:</p>

<p><a href="/images/picasso.jpg">
  <img src="/images/picasso.jpg" style="width:100%;height:100%;" />
</a></p>

<h3 id="picasso">二. 创建及配置<code class="highlighter-rouge">Picasso</code></h3>

<h4 id="picassobuilderpicasso">1. 利用<code class="highlighter-rouge">Picasso.Builder</code>配置<code class="highlighter-rouge">Picasso</code>，主要配置项有：</h4>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// Application运行上下文</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="n">Context</span> <span class="n">context</span><span class="o">;</span>

<span class="c1">// 图片网络下载器</span>
<span class="kd">private</span> <span class="n">Downloader</span> <span class="n">downloader</span><span class="o">;</span>

<span class="c1">// 图片加载线程管理服务</span>
<span class="kd">private</span> <span class="n">ExecutorService</span> <span class="n">service</span><span class="o">;</span>

<span class="c1">// 内存缓存</span>
<span class="kd">private</span> <span class="n">Cache</span> <span class="n">cache</span><span class="o">;</span>

<span class="c1">// 图片加载失败监听器</span>
<span class="kd">private</span> <span class="n">Listener</span> <span class="n">listener</span><span class="o">;</span>

<span class="c1">// 图片加载请求转换器</span>
<span class="kd">private</span> <span class="n">RequestTransformer</span> <span class="n">transformer</span><span class="o">;</span>

<span class="c1">// 图片加载请求处理器</span>
<span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">RequestHandler</span><span class="o">&gt;</span> <span class="n">requestHandlers</span><span class="o">;</span>

<span class="c1">// 图片格式配置</span>
<span class="kd">private</span> <span class="n">Bitmap</span><span class="o">.</span><span class="na">Config</span> <span class="n">defaultBitmapConfig</span><span class="o">;</span>

<span class="c1">// 图片加载来源显示开关，通常在Debug模式下使用</span>
<span class="kd">private</span> <span class="kt">boolean</span> <span class="n">indicatorsEnabled</span><span class="o">;</span>

<span class="c1">// 日志开关</span>
<span class="kd">private</span> <span class="kt">boolean</span> <span class="n">loggingEnabled</span><span class="o">;</span>
</code></pre>
</div>
<p><code class="highlighter-rouge">context</code>必须配置，其他配置项可用默认参数如下所示：</p>

<h5 id="downloader">1.1 默认<code class="highlighter-rouge">Downloader</code></h5>
<p>当应用依赖<a href="https://github.com/square/okhttp"><code class="highlighter-rouge">OkHttp</code></a>模块时，默认使用基于<code class="highlighter-rouge">OkHttp</code>实现<code class="highlighter-rouge">OkHttpDownloader</code>；反之则使用<code class="highlighter-rouge">UrlConnectionDownloader</code>。<code class="highlighter-rouge">Downloader</code>会设置磁盘缓存，默认缓存在应用Cache目录下，缓存设置为Cache的2%并且不小于5M且不大于50M；<code class="highlighter-rouge">OkHttpDownloader</code>基于<code class="highlighter-rouge">OkHttp</code>的缓存模块实现网络响应缓存，<code class="highlighter-rouge">URLConnectionDownloader</code>利用<code class="highlighter-rouge">HttpResponseCache</code>实现，而缓存策略由请求时传入的<code class="highlighter-rouge">networkPolicy</code>控制。</p>

<h5 id="section-1">1.2 默认内存缓存</h5>
<p>内存缓存默认采用<code class="highlighter-rouge">LruCache</code>实现，大小为应用总体内存的15%。</p>

<h5 id="executorservice">1.3 默认<code class="highlighter-rouge">ExecutorService</code></h5>
<p>默认<code class="highlighter-rouge">ExecutorService</code>为<code class="highlighter-rouge">PicassoExecutorService</code>：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">super</span><span class="o">(</span><span class="n">DEFAULT_THREAD_COUNT</span><span class="o">,</span> <span class="n">DEFAULT_THREAD_COUNT</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">,</span>
        <span class="k">new</span> <span class="n">PriorityBlockingQueue</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;(),</span> <span class="k">new</span> <span class="n">Utils</span><span class="o">.</span><span class="na">PicassoThreadFactory</span><span class="o">());</span>
</code></pre>
</div>
<p>该<code class="highlighter-rouge">Service</code>的主要特点是：</p>

<ol>
  <li>可根据网络状态调整线程数量。在Wifi环境下设置为4线程，在4G环境下设置为3线程，在3G环境下设置为2线程，在2G环境下设置为1线程；</li>
  <li>同时将提交的<code class="highlighter-rouge">Runnable</code>（<code class="highlighter-rouge">Picasso</code>中为<code class="highlighter-rouge">RequestHunter</code>）包装为<code class="highlighter-rouge">PicassoFutureTask</code>，由于<code class="highlighter-rouge">Service</code>本身设定为优先级队列，因此<code class="highlighter-rouge">PicassoFutureTask</code>主要实现任务优先级判定规则：
    <ul>
      <li>根据<code class="highlighter-rouge">RequestHunter</code>的<code class="highlighter-rouge">priority</code>实现优先级队列；</li>
      <li>优先级一样的<code class="highlighter-rouge">RequestHunter</code>根据其递增序号实现先入先出队列</li>
    </ul>
  </li>
</ol>

<h5 id="requesttransformer">1.4 默认<code class="highlighter-rouge">RequestTransformer</code></h5>
<p>不做任何转换。</p>

<h5 id="dispatcher">1.5 默认<code class="highlighter-rouge">Dispatcher</code></h5>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 事件分发Handler</span>
<span class="kd">final</span> <span class="n">DispatcherThread</span> <span class="n">dispatcherThread</span><span class="o">;</span>
<span class="kd">final</span> <span class="n">Handler</span> <span class="n">handler</span><span class="o">;</span>

<span class="c1">// 由Picasso传入</span>
<span class="kd">final</span> <span class="n">Context</span> <span class="n">context</span><span class="o">;</span>
<span class="kd">final</span> <span class="n">ExecutorService</span> <span class="n">service</span><span class="o">;</span>
<span class="kd">final</span> <span class="n">Downloader</span> <span class="n">downloader</span><span class="o">;</span>
<span class="kd">final</span> <span class="n">Cache</span> <span class="n">cache</span><span class="o">;</span>

<span class="c1">// Action包装一个图片请求Request，可以理解为一个图片请求任务，实现了图片加载成功或失败的回调处理</span>
<span class="c1">// key为Action.key, value为图片请求Runnable，存储所有图片请求</span>
<span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">BitmapHunter</span><span class="o">&gt;</span> <span class="n">hunterMap</span><span class="o">;</span>
<span class="c1">// key为Action.Target, value为Action，记录失败请求</span>
<span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">,</span> <span class="n">Action</span><span class="o">&gt;</span> <span class="n">failedActions</span><span class="o">;</span>
<span class="c1">// key为Action.Target, value为Action，记录暂停请求</span>
<span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">,</span> <span class="n">Action</span><span class="o">&gt;</span> <span class="n">pausedActions</span><span class="o">;</span>
<span class="c1">// key为Action.tag, 被暂停的tag，tag标识一组相关请求</span>
<span class="kd">final</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">pausedTags</span><span class="o">;</span>

<span class="c1">// 主线程Handler，用于转发如UI刷新等需在主线程处理的事件</span>
<span class="kd">final</span> <span class="n">Handler</span> <span class="n">mainThreadHandler</span><span class="o">;</span>

<span class="c1">// 统计图片加载及缓存数据，生成内存快照</span>
<span class="kd">final</span> <span class="n">Stats</span> <span class="n">stats</span><span class="o">;</span>

<span class="c1">// 记录成功或失败的BitmapHunter，作为发送到主线程的事件的参数，用于回调complete或error</span>
<span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">BitmapHunter</span><span class="o">&gt;</span> <span class="n">batch</span><span class="o">;</span>
</code></pre>
</div>
<p><code class="highlighter-rouge">Dispatcher</code>的核心在于利用<code class="highlighter-rouge">DispatchThread</code>实现统一的事件分发器，统一处理图片请求、取消、响应、重试、完成或错误等事件。</p>

<h5 id="section-2">1.6 默认链式图片请求处理器</h5>
<p><code class="highlighter-rouge">RequestHandler</code>是图片处理器基类，主要包含以下接口：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 是否能处理当前请求</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">boolean</span> <span class="nf">canHandleRequest</span><span class="p">(</span><span class="n">Request</span> <span class="n">data</span><span class="o">);</span>

<span class="c1">// 根据当前请求以及网络策略加载相应图片，并将结果包装成Result</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="n">Result</span> <span class="nf">load</span><span class="p">(</span><span class="n">Request</span> <span class="n">request</span><span class="o">,</span> <span class="kt">int</span> <span class="n">networkPolicy</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">;</span>

<span class="c1">// 重试次数</span>
<span class="kt">int</span> <span class="nf">getRetryCount</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 当前环境下是否可以重试</span>
<span class="kt">boolean</span> <span class="nf">shouldRetry</span><span class="p">(</span><span class="kt">boolean</span> <span class="n">airplaneMode</span><span class="o">,</span> <span class="n">NetworkInfo</span> <span class="n">info</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 是否支持重新加载</span>
<span class="kt">boolean</span> <span class="nf">supportsReplay</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>
<p>处理器根据请求完成图片加载之后会将得到的<code class="highlighter-rouge">Bitmap</code>或者<code class="highlighter-rouge">InputStream</code>包装成<code class="highlighter-rouge">Result</code>返回，用于后续图片处理，<code class="highlighter-rouge">Picasso</code>会添加7个默认处理器，如下所示：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">List</span><span class="o">&lt;</span><span class="n">RequestHandler</span><span class="o">&gt;</span> <span class="n">allRequestHandlers</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">RequestHandler</span><span class="o">&gt;();</span>
<span class="n">allRequestHandlers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">ResourceRequestHandler</span><span class="o">(</span><span class="n">context</span><span class="o">));</span>
<span class="k">if</span> <span class="o">(</span><span class="n">extraRequestHandlers</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">allRequestHandlers</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">extraRequestHandlers</span><span class="o">);</span>
<span class="o">}</span>
<span class="n">allRequestHandlers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">ContactsPhotoRequestHandler</span><span class="o">(</span><span class="n">context</span><span class="o">));</span>
<span class="n">allRequestHandlers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">MediaStoreRequestHandler</span><span class="o">(</span><span class="n">context</span><span class="o">));</span>
<span class="n">allRequestHandlers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">ContentStreamRequestHandler</span><span class="o">(</span><span class="n">context</span><span class="o">));</span>
<span class="n">allRequestHandlers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">AssetRequestHandler</span><span class="o">(</span><span class="n">context</span><span class="o">));</span>
<span class="n">allRequestHandlers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">FileRequestHandler</span><span class="o">(</span><span class="n">context</span><span class="o">));</span>
<span class="n">allRequestHandlers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">NetworkRequestHandler</span><span class="o">(</span><span class="n">dispatcher</span><span class="o">.</span><span class="na">downloader</span><span class="o">,</span> <span class="n">stats</span><span class="o">));</span>
</code></pre>
</div>
<p>以下简单分析每个<code class="highlighter-rouge">RequestHandler</code>处理的请求类型以及处理逻辑：</p>

<p><strong>ResourceRequestHandler</strong>  <br />
<em>canHandleRequest:</em></p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 匹配规则，SCHEME_ANDROID_RESOURCE=‘android.resource’</span>
<span class="n">resourceId</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">SCHEME_ANDROID_RESOURCE</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">uri</span><span class="o">.</span><span class="na">getScheme</span><span class="o">())</span>
</code></pre>
</div>
<p><em>load:</em>  <br />
根据<code class="highlighter-rouge">Request</code>中的相关配置生成<code class="highlighter-rouge">BitmapFactory.Options</code>，解析<code class="highlighter-rouge">ResourceId</code>对应的资源图片，封装成<code class="highlighter-rouge">Result(bitmap, DISK)</code></p>

<p><strong>ContactsPhotoRequestHandler</strong>  <br />
<em>canHandleRequest:</em></p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 可处理Uri</span>
<span class="kd">static</span> <span class="o">{</span>
    <span class="n">matcher</span> <span class="o">=</span> <span class="k">new</span> <span class="n">UriMatcher</span><span class="o">(</span><span class="n">UriMatcher</span><span class="o">.</span><span class="na">NO_MATCH</span><span class="o">);</span>
    <span class="n">matcher</span><span class="o">.</span><span class="na">addURI</span><span class="o">(</span><span class="n">ContactsContract</span><span class="o">.</span><span class="na">AUTHORITY</span><span class="o">,</span> <span class="s">"contacts/lookup/*/#"</span><span class="o">,</span> <span class="n">ID_LOOKUP</span><span class="o">);</span>
    <span class="n">matcher</span><span class="o">.</span><span class="na">addURI</span><span class="o">(</span><span class="n">ContactsContract</span><span class="o">.</span><span class="na">AUTHORITY</span><span class="o">,</span> <span class="s">"contacts/lookup/*"</span><span class="o">,</span> <span class="n">ID_LOOKUP</span><span class="o">);</span>
    <span class="n">matcher</span><span class="o">.</span><span class="na">addURI</span><span class="o">(</span><span class="n">ContactsContract</span><span class="o">.</span><span class="na">AUTHORITY</span><span class="o">,</span> <span class="s">"contacts/#/photo"</span><span class="o">,</span> <span class="n">ID_THUMBNAIL</span><span class="o">);</span>
    <span class="n">matcher</span><span class="o">.</span><span class="na">addURI</span><span class="o">(</span><span class="n">ContactsContract</span><span class="o">.</span><span class="na">AUTHORITY</span><span class="o">,</span> <span class="s">"contacts/#"</span><span class="o">,</span> <span class="n">ID_CONTACT</span><span class="o">);</span>
    <span class="n">matcher</span><span class="o">.</span><span class="na">addURI</span><span class="o">(</span><span class="n">ContactsContract</span><span class="o">.</span><span class="na">AUTHORITY</span><span class="o">,</span> <span class="s">"display_photo/#"</span><span class="o">,</span> <span class="n">ID_DISPLAY_PHOTO</span><span class="o">);</span>
  <span class="o">}</span>

<span class="c1">// 匹配规则, SCHEME_CONTENT='content', AUTHORITY = "com.android.contacts"</span>
<span class="o">(</span><span class="n">SCHEME_CONTENT</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">uri</span><span class="o">.</span><span class="na">getScheme</span><span class="o">())</span>
        <span class="o">&amp;&amp;</span> <span class="n">ContactsContract</span><span class="o">.</span><span class="na">Contacts</span><span class="o">.</span><span class="na">CONTENT_URI</span><span class="o">.</span><span class="na">getHost</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">uri</span><span class="o">.</span><span class="na">getHost</span><span class="o">())</span>
        <span class="o">&amp;&amp;</span> <span class="n">matcher</span><span class="o">.</span><span class="na">match</span><span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">uri</span><span class="o">)</span> <span class="o">!=</span> <span class="n">UriMatcher</span><span class="o">.</span><span class="na">NO_MATCH</span><span class="o">);</span>
</code></pre>
</div>
<p><em>load:</em>  <br />
根据合法<code class="highlighter-rouge">Uri</code>利用<code class="highlighter-rouge">ContentResolver</code>获取相应联系人的photo的数据流，封装成<code class="highlighter-rouge">Result(inputstream, DISK)</code></p>

<p><strong>MediaStoreRequestHandler</strong>  <br />
<em>canHandleRequest:</em></p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 匹配规则，SCHEME_CONTENT='content'，AUTHORITY = "media";</span>
<span class="o">(</span><span class="n">SCHEME_CONTENT</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">uri</span><span class="o">.</span><span class="na">getScheme</span><span class="o">())</span>
            <span class="o">&amp;&amp;</span> <span class="n">MediaStore</span><span class="o">.</span><span class="na">AUTHORITY</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">uri</span><span class="o">.</span><span class="na">getAuthority</span><span class="o">()));</span>
</code></pre>
</div>
<p><em>load:</em>  <br />
根据合法<code class="highlighter-rouge">Uri</code>利用<code class="highlighter-rouge">Video.Thumbnails.getThumbnail</code>或<code class="highlighter-rouge">Images.Thumbnails.getThumbnail</code>解析相应<code class="highlighter-rouge">Image</code>或<code class="highlighter-rouge">Video</code>获得图片数据流，封装成<code class="highlighter-rouge">Result(inputstream, DISK)</code></p>

<p><strong>ContentStreamRequestHandler</strong>  <br />
<em>canHandleRequest:</em></p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 匹配规则，SCHEME_CONTENT='content'</span>
<span class="n">SCHEME_CONTENT</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">uri</span><span class="o">.</span><span class="na">getScheme</span><span class="o">());</span>
</code></pre>
</div>
<p><em>load:</em>  <br />
 利用<code class="highlighter-rouge">ContentResolver.openInputStream</code>获取<code class="highlighter-rouge">Uri</code>对应资源的数据流，封装成<code class="highlighter-rouge">Result(inputstream, DISK)</code></p>

<p><strong>AssetRequestHandler</strong>  <br />
<em>canHandleRequest:</em></p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 匹配规则，‘file://packagename/anroid_asset/...’</span>
<span class="o">(</span><span class="n">SCHEME_FILE</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">uri</span><span class="o">.</span><span class="na">getScheme</span><span class="o">())</span>
        <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">uri</span><span class="o">.</span><span class="na">getPathSegments</span><span class="o">().</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">ANDROID_ASSET</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">uri</span><span class="o">.</span><span class="na">getPathSegments</span><span class="o">().</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">)));</span>
</code></pre>
</div>
<p><em>load:</em>  <br />
 加载<code class="highlighter-rouge">asset</code>中由<code class="highlighter-rouge">Uri</code>指定的资源的数据流，封装成<code class="highlighter-rouge">Result(inputstream, DISK)</code></p>

<p><strong>FileRequestHandler</strong>  <br />
<em>canHandleRequest:</em></p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">//匹配规则，SCHEME_FILE=‘file’</span>
<span class="n">SCHEME_FILE</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">uri</span><span class="o">.</span><span class="na">getScheme</span><span class="o">());</span>
</code></pre>
</div>
<p><em>load:</em>  <br />
 读取相应的文件输入流，获取相应文件中可能存在的<code class="highlighter-rouge">ExifInterface.Orientation</code>，封装成<code class="highlighter-rouge">Result(null, in, DISK, orientation)</code></p>

<p><strong>NetworkRequestHandler</strong>  <br />
<em>canHandleRequest:</em></p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="o">(</span><span class="n">SCHEME_HTTP</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">scheme</span><span class="o">)</span> <span class="o">||</span> <span class="n">SCHEME_HTTPS</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">scheme</span><span class="o">));</span>
</code></pre>
</div>
<p><em>load:</em>  <br />
 获取磁盘缓存或网络上的图片，封装成<code class="highlighter-rouge">Result(bitmap, loadedFrom)</code>或者<code class="highlighter-rouge">Result(in, loadedFrom)</code></p>

<h4 id="section-3">2. 未配置参数</h4>
<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// key为Action.target，Pause时记录相应的Action，Resume的时候记录的Action</span>
<span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">,</span> <span class="n">Action</span><span class="o">&gt;</span> <span class="n">targetToAction</span><span class="o">;</span>
<span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">ImageView</span><span class="o">,</span> <span class="n">DeferredRequestCreator</span><span class="o">&gt;</span> <span class="n">targetToDeferredRequestCreator</span><span class="o">;</span>

<span class="c1">// 由于Action中对target持有弱引用，因此当target被回收之后便会进入referenceQueue，</span>
<span class="c1">// 而相应的Action变为无效Action，通过cleanupThread中的loop循环实现对无效Action的清理。</span>
<span class="kd">final</span> <span class="n">ReferenceQueue</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">referenceQueue</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="n">CleanupThread</span> <span class="n">cleanupThread</span><span class="o">;</span>
</code></pre>
</div>

<h3 id="section-4">三、图片加载缓存过程详解</h3>

<h4 id="picassoload">1. 调用<code class="highlighter-rouge">Picasso.load</code>启动图片加载流程：</h4>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">RequestCreator</span> <span class="nf">load</span><span class="p">(</span><span class="n">Uri</span> <span class="n">uri</span><span class="o">)</span>
<span class="kd">public</span> <span class="n">RequestCreator</span> <span class="nf">load</span><span class="p">(</span><span class="n">String</span> <span class="n">path</span><span class="o">)</span>
<span class="kd">public</span> <span class="n">RequestCreator</span> <span class="nf">load</span><span class="p">(</span><span class="n">File</span> <span class="n">file</span><span class="o">)</span>
<span class="kd">public</span> <span class="n">RequestCreator</span> <span class="nf">load</span><span class="p">(</span><span class="kt">int</span> <span class="n">resourceId</span><span class="o">)</span>
</code></pre>
</div>
<p><code class="highlighter-rouge">path</code>及<code class="highlighter-rouge">file</code>均会转换成相应的<code class="highlighter-rouge">uri</code>，从而实际<code class="highlighter-rouge">Picasso</code>处理<code class="highlighter-rouge">uri</code>及<code class="highlighter-rouge">resourceId</code>两种形式的请求，这也是<code class="highlighter-rouge">Picasso</code>的默认请求处理器中<code class="highlighter-rouge">canHandleRequest</code>都是通过<code class="highlighter-rouge">uri</code>来进行判断的原因。而两种类型的<code class="highlighter-rouge">load</code>操作最终返回的都是新建的一个<code class="highlighter-rouge">RequestCreator</code>，于是<code class="highlighter-rouge">RequestCreator</code>也必须支持<code class="highlighter-rouge">resourceId</code>以及<code class="highlighter-rouge">uri</code>两种形式<code class="highlighter-rouge">Request</code>的构建，并且这两种形式是互斥的，即非此即彼。</p>

<h4 id="requestcreator">2. RequestCreator的工作</h4>
<p><code class="highlighter-rouge">RequestCreator</code>就是一个<code class="highlighter-rouge">Request</code>的生成器，其有一些基本配置项：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 设置图片时是否做渐显效果</span>
<span class="kd">private</span> <span class="kt">boolean</span> <span class="n">noFade</span><span class="o">;</span>
<span class="c1">// 是否延迟加载图片，可延迟至ImageView的宽高确定后再发起加载请求</span>
<span class="kd">private</span> <span class="kt">boolean</span> <span class="n">deferred</span><span class="o">;</span>
<span class="c1">// 是否设置占位图</span>
<span class="kd">private</span> <span class="kt">boolean</span> <span class="n">setPlaceholder</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
<span class="c1">// 占位图资源Id</span>
<span class="kd">private</span> <span class="kt">int</span> <span class="n">placeholderResId</span><span class="o">;</span>
<span class="c1">// 加载失败图资源Id</span>
<span class="kd">private</span> <span class="kt">int</span> <span class="n">errorResId</span><span class="o">;</span>
<span class="c1">// 内存加载缓存策略</span>
<span class="kd">private</span> <span class="kt">int</span> <span class="n">memoryPolicy</span><span class="o">;</span>
<span class="c1">// 网络加载缓存策略</span>
<span class="kd">private</span> <span class="kt">int</span> <span class="n">networkPolicy</span><span class="o">;</span>
<span class="c1">// 占位图drawable</span>
<span class="kd">private</span> <span class="n">Drawable</span> <span class="n">placeholderDrawable</span><span class="o">;</span>
<span class="c1">// 加载失败图drawable</span>
<span class="kd">private</span> <span class="n">Drawable</span> <span class="n">errorDrawable</span><span class="o">;</span>
<span class="c1">// 将请求关联到该tag，用于处理pause及resume</span>
<span class="kd">private</span> <span class="n">Object</span> <span class="n">tag</span><span class="o">;</span>
</code></pre>
</div>
<p>除了这些配置项之外，还可以通过一个<code class="highlighter-rouge">Request.Builder</code>来配置<code class="highlighter-rouge">Request</code>：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 图片加载uri</span>
<span class="kd">private</span> <span class="n">Uri</span> <span class="n">uri</span><span class="o">;</span>
<span class="c1">// 图片资源Id</span>
<span class="kd">private</span> <span class="kt">int</span> <span class="n">resourceId</span><span class="o">;</span>
<span class="c1">// 设定的缓存key</span>
<span class="kd">private</span> <span class="n">String</span> <span class="n">stableKey</span><span class="o">;</span>
<span class="c1">// 图片宽高</span>
<span class="kd">private</span> <span class="kt">int</span> <span class="n">targetWidth</span><span class="o">;</span>
<span class="kd">private</span> <span class="kt">int</span> <span class="n">targetHeight</span><span class="o">;</span>
<span class="c1">// 图片缩放策略</span>
<span class="kd">private</span> <span class="kt">boolean</span> <span class="n">centerCrop</span><span class="o">;</span>
<span class="kd">private</span> <span class="kt">boolean</span> <span class="n">centerInside</span><span class="o">;</span>
<span class="c1">// 是否仅向下缩放</span>
<span class="kd">private</span> <span class="kt">boolean</span> <span class="n">onlyScaleDown</span><span class="o">;</span>
<span class="c1">// 旋转参数</span>
<span class="kd">private</span> <span class="kt">float</span> <span class="n">rotationDegrees</span><span class="o">;</span>
<span class="kd">private</span> <span class="kt">float</span> <span class="n">rotationPivotX</span><span class="o">;</span>
<span class="kd">private</span> <span class="kt">float</span> <span class="n">rotationPivotY</span><span class="o">;</span>
<span class="kd">private</span> <span class="kt">boolean</span> <span class="n">hasRotationPivot</span><span class="o">;</span>
<span class="c1">// 图片转换器列表</span>
<span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Transformation</span><span class="o">&gt;</span> <span class="n">transformations</span><span class="o">;</span>
<span class="c1">// 图片格式</span>
<span class="kd">private</span> <span class="n">Bitmap</span><span class="o">.</span><span class="na">Config</span> <span class="n">config</span><span class="o">;</span>
<span class="c1">// 任务优先级</span>
<span class="kd">private</span> <span class="n">Priority</span> <span class="n">priority</span><span class="o">;</span>
</code></pre>
</div>
<p>配置完成之后便可以调用<code class="highlighter-rouge">Request.Builder.build</code>生成<code class="highlighter-rouge">Request</code>，而创建的<code class="highlighter-rouge">Request</code>还必须设置以下属性：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 请求唯一Id</span>
<span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
<span class="c1">// 请求发起时间</span>
<span class="kt">long</span> <span class="n">started</span><span class="o">;</span>
<span class="c1">//  网络加载缓存策略</span>
<span class="kt">int</span> <span class="n">networkPolicy</span><span class="o">;</span>
</code></pre>
</div>
<p>这几个属性是在调用<code class="highlighter-rouge">RequestCreator</code>发起请求的接口是设置的，其提供以下发起请求的接口:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 在当前线程获取图片</span>
<span class="kd">public</span> <span class="n">Bitmap</span> <span class="nf">get</span><span class="p">(</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> 

<span class="c1">// 由Dispatcher统一调度根据Action生成BitmapHunter，然后将BitmapHunter提交给PicassoExecutorService，</span>
<span class="c1">// 并将Action记录在Dispatcher中；PicassoExecutorService则根据当前所有任务的优先级逐个运行BitmapHunter</span>
<span class="c1">// 的hunt方法，获取到图片之后有dispatcher统一调度调用相应Action的完成或失败回调，后续会详细分析。</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">fetch</span><span class="p">(</span><span class="n">Callback</span> <span class="n">callback</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">into</span><span class="p">(</span><span class="n">Target</span> <span class="n">target</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">into</span><span class="p">(</span><span class="n">RemoteViews</span> <span class="n">remoteViews</span><span class="o">,</span> <span class="kt">int</span> <span class="n">viewId</span><span class="o">,</span> <span class="kt">int</span> <span class="n">notificationId</span><span class="o">,</span> <span class="n">Notification</span> <span class="n">notification</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">into</span><span class="p">(</span><span class="n">RemoteViews</span> <span class="n">remoteViews</span><span class="o">,</span> <span class="kt">int</span> <span class="n">viewId</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">appWidgetIds</span><span class="o">)</span> 
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">into</span><span class="p">(</span><span class="n">ImageView</span> <span class="n">target</span><span class="o">,</span> <span class="n">Callback</span> <span class="n">callback</span><span class="o">)</span>

</code></pre>
</div>
<p>我们逐个看下里面具体有哪些猫腻：</p>

<h5 id="get">get()</h5>
<p>这是所有发起请求接口中唯一不提交到<code class="highlighter-rouge">PicassoExecutorService</code>执行的接口，由于是直接在当前线程加载图片，因此该接口禁止在主线程中调用。首先生成<code class="highlighter-rouge">Request</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="n">Request</span> <span class="nf">createRequest</span><span class="p">(</span><span class="kt">long</span> <span class="n">started</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">nextId</span><span class="o">.</span><span class="na">getAndIncrement</span><span class="o">();</span>
    <span class="n">Request</span> <span class="n">request</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="na">build</span><span class="o">();</span>
    <span class="n">request</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
    <span class="n">request</span><span class="o">.</span><span class="na">started</span> <span class="o">=</span> <span class="n">started</span><span class="o">;</span>
    <span class="n">Request</span> <span class="n">transformed</span> <span class="o">=</span> <span class="n">picasso</span><span class="o">.</span><span class="na">transformRequest</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">transformed</span> <span class="o">!=</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">transformed</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
      <span class="n">transformed</span><span class="o">.</span><span class="na">started</span> <span class="o">=</span> <span class="n">started</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">transformed</span><span class="o">;</span>
  <span class="o">}</span>
</code></pre>
</div>
<p>以上源码已删除日志相关的部分，首先通过<code class="highlighter-rouge">Request.Builder</code>创建出<code class="highlighter-rouge">Request</code>，然后用<code class="highlighter-rouge">Picasso</code>中配置的<code class="highlighter-rouge">Request</code>转换器进行预处理后得到最终<code class="highlighter-rouge">Request</code>，然后生成该<code class="highlighter-rouge">Request</code>的请求<code class="highlighter-rouge">Key</code>，并然后创建<code class="highlighter-rouge">GetAction</code>，<code class="highlighter-rouge">Action</code>标识一次请求行为，作为以下数据的载体：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">final</span> <span class="n">Picasso</span> <span class="n">picasso</span><span class="o">;</span>

<span class="c1">// 请求发起target的弱引用，与Picasso中的cleanThread配合实现对无效Action的清除</span>
<span class="kd">final</span> <span class="n">WeakReference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">target</span><span class="o">;</span>

<span class="c1">// 以下数据含义见RequestCreator</span>
<span class="kd">final</span> <span class="n">Request</span> <span class="n">request</span><span class="o">;</span>
<span class="kd">final</span> <span class="kt">boolean</span> <span class="n">noFade</span><span class="o">;</span>
<span class="kd">final</span> <span class="kt">int</span> <span class="n">memoryPolicy</span><span class="o">;</span>
<span class="kd">final</span> <span class="kt">int</span> <span class="n">networkPolicy</span><span class="o">;</span>
<span class="kd">final</span> <span class="kt">int</span> <span class="n">errorResId</span><span class="o">;</span>
<span class="kd">final</span> <span class="n">Drawable</span> <span class="n">errorDrawable</span><span class="o">;</span>
<span class="kd">final</span> <span class="n">String</span> <span class="n">key</span><span class="o">;</span>
<span class="kd">final</span> <span class="n">Object</span> <span class="n">tag</span><span class="o">;</span>

<span class="c1">// 是否处于等待重新加载状态</span>
<span class="kt">boolean</span> <span class="n">willReplay</span><span class="o">;</span>
<span class="c1">// 是否已取消</span>
<span class="kt">boolean</span> <span class="n">cancelled</span><span class="o">;</span>
</code></pre>
</div>
<p>同时<code class="highlighter-rouge">Action</code>要求子类实现图片加载成功或失败的回调方法：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">complete</span><span class="p">(</span><span class="n">Bitmap</span> <span class="n">result</span><span class="o">,</span> <span class="n">Picasso</span><span class="o">.</span><span class="na">LoadedFrom</span> <span class="n">from</span><span class="o">);</span>
<span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">error</span><span class="p">(</span><span class="o">);</span>
</code></pre>
</div>
<p>而继承自<code class="highlighter-rouge">Action</code>的<code class="highlighter-rouge">GetAction</code>在这两个方法中不做任何处理，后续会解释为什么不用做处理。
获得<code class="highlighter-rouge">Action</code>之后，便使用该<code class="highlighter-rouge">Action</code>创建<code class="highlighter-rouge">BitmapHunter</code>，该类继承自<code class="highlighter-rouge">Runnable</code>，因此可以提交给<code class="highlighter-rouge">ExecutorService</code>执行，它包含以下属性：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 递增生成的序列号，用于将优先级一样的请求实现为先入先出队列</span>
<span class="kd">final</span> <span class="kt">int</span> <span class="n">sequence</span><span class="o">;</span>

<span class="c1">// 以下数据含义见RequestCreator</span>
<span class="kd">final</span> <span class="n">Picasso</span> <span class="n">picasso</span><span class="o">;</span>
<span class="kd">final</span> <span class="n">Dispatcher</span> <span class="n">dispatcher</span><span class="o">;</span>
<span class="kd">final</span> <span class="n">Cache</span> <span class="n">cache</span><span class="o">;</span>
<span class="kd">final</span> <span class="n">Stats</span> <span class="n">stats</span><span class="o">;</span>
<span class="kd">final</span> <span class="n">String</span> <span class="n">key</span><span class="o">;</span>
<span class="kd">final</span> <span class="n">Request</span> <span class="n">data</span><span class="o">;</span>
<span class="kd">final</span> <span class="kt">int</span> <span class="n">memoryPolicy</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">networkPolicy</span><span class="o">;</span>

<span class="c1">// 遍历Picasso中预设的所有图片请求处理器得到，是根据resourceId或uri获取图片的核心类</span>
<span class="kd">final</span> <span class="n">RequestHandler</span> <span class="n">requestHandler</span><span class="o">;</span>

<span class="c1">// 初始化时设定的Action</span>
<span class="n">Action</span> <span class="n">action</span><span class="o">;</span>
<span class="c1">// 运行时添加到该Hunter的Action</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">Action</span><span class="o">&gt;</span> <span class="n">actions</span><span class="o">;</span>
<span class="c1">// 完成Action之后得到的最终图片</span>
<span class="n">Bitmap</span> <span class="n">result</span><span class="o">;</span>
<span class="c1">// 提交到PicassoExecutorService之后返回的PicassoFutureTask，用于取消该Hunter</span>
<span class="n">Future</span><span class="o">&lt;?&gt;</span> <span class="n">future</span><span class="o">;</span>
<span class="c1">// 图片加载来源（MEMORY、DISK、NETWORK），</span>
<span class="c1">// 当设定了Picasso.indicatorsEnabled时会在设定图片时用加载来源对应的颜色表示该图片</span>
<span class="n">Picasso</span><span class="o">.</span><span class="na">LoadedFrom</span> <span class="n">loadedFrom</span><span class="o">;</span>
<span class="c1">// 请求过程中抛出的异常</span>
<span class="n">Exception</span> <span class="n">exception</span><span class="o">;</span>
<span class="c1">// 当图片类型为EXIF时，解析出其中的旋转参数</span>
<span class="kt">int</span> <span class="n">exifRotation</span><span class="o">;</span>
<span class="c1">// 可重试次数</span>
<span class="kt">int</span> <span class="n">retryCount</span><span class="o">;</span>
<span class="c1">// 任务优先级，由action及actions中所有Action的最高优先级决定</span>
<span class="n">Priority</span> <span class="n">priority</span><span class="o">;</span>
</code></pre>
</div>
<p>创建了可运行<code class="highlighter-rouge">GetAction</code>的<code class="highlighter-rouge">BitmapHunter</code>之后便调用其<code class="highlighter-rouge">hunt</code>方法获取相应的图片，由于该方法直接返回<code class="highlighter-rouge">hunt</code>得到的图片，因此无需再<code class="highlighter-rouge">Action</code>得<code class="highlighter-rouge">complete</code>或<code class="highlighter-rouge">error</code>中做任何处理，而<code class="highlighter-rouge">BitmapHunter</code>的具体执行过程后文进行分析。</p>

<h5 id="fetchcallback-callback">fetch(Callback callback)</h5>
<p>需通过<code class="highlighter-rouge">Dispatcher</code>提交到<code class="highlighter-rouge">PicassoExecutorService</code>执行，该接口创建<code class="highlighter-rouge">FetchAction</code>，特点是不用设定<code class="highlighter-rouge">Target</code>，因此可用于图片的预加载，当图片加载成功之后回调<code class="highlighter-rouge">Callback</code>的成功或失败回调方法。创建得到<code class="highlighter-rouge">Action</code>之后调用<code class="highlighter-rouge">picasso.submit(action)</code>提交请求，由于<code class="highlighter-rouge">into</code>相关接口的提交细节与<code class="highlighter-rouge">fetch</code>一致，因此在后文统一分析。值得一提的是，fetch的时候会先检查内存缓存，只有当内存缓存中没有对应图片的时候才提交任务，后续<code class="highlighter-rouge">into</code>相关接口亦采用了类似的策略。</p>

<h5 id="intotarget-target">into(Target target)</h5>
<p>创建<code class="highlighter-rouge">TargetAction</code>，并与传入的<code class="highlighter-rouge">target</code>绑定，而<code class="highlighter-rouge">Target</code>接口包含以下方法：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 图片加载成功</span>
<span class="kt">void</span> <span class="nf">onBitmapLoaded</span><span class="p">(</span><span class="n">Bitmap</span> <span class="n">bitmap</span><span class="o">,</span> <span class="n">LoadedFrom</span> <span class="n">from</span><span class="o">);</span>
<span class="c1">// 图片加载失败</span>
<span class="kt">void</span> <span class="nf">onBitmapFailed</span><span class="p">(</span><span class="n">Drawable</span> <span class="n">errorDrawable</span><span class="o">);</span>
<span class="c1">// 图片开始加载</span>
<span class="kt">void</span> <span class="nf">onPrepareLoad</span><span class="p">(</span><span class="n">Drawable</span> <span class="n">placeHolderDrawable</span><span class="o">);</span>
</code></pre>
</div>
<p>因此在提交任务之前会回调<code class="highlighter-rouge">onPrepareLoad</code>，提交任务完成之后会根据结果在<code class="highlighter-rouge">Action</code>中回调方法中回调<code class="highlighter-rouge">Target</code>的<code class="highlighter-rouge">onBitmapLoaded</code>或<code class="highlighter-rouge">onBitmapFailed</code>，由于该<code class="highlighter-rouge">Action</code>指定了<code class="highlighter-rouge">target</code>，因此采用<code class="highlighter-rouge">Picasso.enqueueAndSubmit</code>来提交任务，与<code class="highlighter-rouge">submit</code>的区别在于会以该<code class="highlighter-rouge">target</code>为<code class="highlighter-rouge">key</code>将对应<code class="highlighter-rouge">Action</code>记录在<code class="highlighter-rouge">Picasso</code>中，记录新<code class="highlighter-rouge">Action</code>的时候取消之前设定的<code class="highlighter-rouge">Action</code>。</p>

<h5 id="intoremoteviews-remoteviews-int-viewid-int-notificationid-notification-notification">into(RemoteViews remoteViews, int viewId, int notificationId, Notification notification)</h5>
<p>创建<code class="highlighter-rouge">NotificationAction</code>，并根据传入的<code class="highlighter-rouge">remoteViews</code>及<code class="highlighter-rouge">viewId</code>创建<code class="highlighter-rouge">RemoteViewsTarget</code>，用于将加载好的图片设定给指定的<code class="highlighter-rouge">View</code>。而<code class="highlighter-rouge">notificationId</code>及<code class="highlighter-rouge">notification</code>用于在设定了图片之后进行刷新：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">NotificationManager</span> <span class="n">manager</span> <span class="o">=</span> <span class="n">getService</span><span class="o">(</span><span class="n">picasso</span><span class="o">.</span><span class="na">context</span><span class="o">,</span> <span class="n">NOTIFICATION_SERVICE</span><span class="o">);</span>
<span class="n">manager</span><span class="o">.</span><span class="na">notify</span><span class="o">(</span><span class="n">notificationId</span><span class="o">,</span> <span class="n">notification</span><span class="o">);</span>
</code></pre>
</div>
<p>这样就实现对RemoteViews的更新。</p>

<h5 id="intoremoteviews-remoteviews-int-viewid-int-appwidgetids">into(RemoteViews remoteViews, int viewId, int[] appWidgetIds)</h5>
<p>创建<code class="highlighter-rouge">AppWidgetAction</code>，类似于<code class="highlighter-rouge">NotificationAction</code>，通过调用：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">AppWidgetManager</span> <span class="n">manager</span> <span class="o">=</span> <span class="n">AppWidgetManager</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">picasso</span><span class="o">.</span><span class="na">context</span><span class="o">);</span>
<span class="n">manager</span><span class="o">.</span><span class="na">updateAppWidget</span><span class="o">(</span><span class="n">appWidgetIds</span><span class="o">,</span> <span class="n">remoteViews</span><span class="o">);</span>
</code></pre>
</div>
<p>实现对<code class="highlighter-rouge">RemoteViews</code>的更新。</p>

<h5 id="intoimageview-target-callback-callback">into(ImageView target, Callback callback)</h5>
<p>以<code class="highlighter-rouge">ImageView</code>为<code class="highlighter-rouge">target</code>创建<code class="highlighter-rouge">ImageViewAction</code>，在提交任务之前会用占位图更新<code class="highlighter-rouge">ImageView</code>，在任务完成之后用加载得到的图片或加载错误图片更新<code class="highlighter-rouge">ImageView</code>，值得一提的是，在使用占位图及加载成功图片更新的时候会将图片包装成<code class="highlighter-rouge">PicassoDrawable</code>以实现渐显的效果。
如果你仅仅觉得这个<code class="highlighter-rouge">Action</code>如此简单，那你就输了，它要祭起大杀器了——《延迟加载》，只有<code class="highlighter-rouge">ImageView</code>作为<code class="highlighter-rouge">Target</code>的<code class="highlighter-rouge">Action</code>才可以设置延迟加载，当设定了<code class="highlighter-rouge">RequestCreator.deferred</code>且<code class="highlighter-rouge">ImageView</code>的宽或高等于0时，会将该<code class="highlighter-rouge">RequestCreator</code>包装成<code class="highlighter-rouge">DeferredRequestCreator</code>，然后记录到<code class="highlighter-rouge">Picasso</code>中，<code class="highlighter-rouge">DeferredRequestCreator</code>实现了<code class="highlighter-rouge">ViewTreeObserver</code>.<code class="highlighter-rouge">OnPreDrawListener</code>接口，在<code class="highlighter-rouge">onPreDraw</code>中设定<code class="highlighter-rouge">Request</code>的<code class="highlighter-rouge">targetWidth</code>及<code class="highlighter-rouge">targetHeight</code>并重新调用<code class="highlighter-rouge">RequestCreator.into(ImageView target, Callback callback)</code>实现加载，这样可以有效的控制加载图片的大小，从而达到节省内存的目的。</p>

<p>通过以上方法完成请求的发起之后，<code class="highlighter-rouge">RequestCreator</code>的工作就完成了，接下来就由<code class="highlighter-rouge">Dispatcher</code>及<code class="highlighter-rouge">PicassoExecutorService</code>接手来处理请求。</p>

<h4 id="dispatcher-1">3. Dispatcher提交任务</h4>
<p>通过调用<code class="highlighter-rouge">Picasso.submit</code>或<code class="highlighter-rouge">Picasso.enqueueAndSubmit</code>可以提交上文中创建的<code class="highlighter-rouge">Action</code>，后者相对于前者的区别在于会以<code class="highlighter-rouge">Action</code>.<code class="highlighter-rouge">target</code>为<code class="highlighter-rouge">key</code>记录该<code class="highlighter-rouge">Action</code>，两者最终均调用<code class="highlighter-rouge">dispatcher.dispatchSubmit</code>，由<code class="highlighter-rouge">Dispatcher</code>来实现任务的统一提交，实际的处理逻辑则在<code class="highlighter-rouge">performSubmit</code>方法中：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">performSubmit</span><span class="p">(</span><span class="n">Action</span> <span class="n">action</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">dismissFailed</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">pausedTags</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">action</span><span class="o">.</span><span class="na">getTag</span><span class="o">()))</span> <span class="o">{</span>
      <span class="n">pausedActions</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">action</span><span class="o">.</span><span class="na">getTarget</span><span class="o">(),</span> <span class="n">action</span><span class="o">);</span>
      <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">BitmapHunter</span> <span class="n">hunter</span> <span class="o">=</span> <span class="n">hunterMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">action</span><span class="o">.</span><span class="na">getKey</span><span class="o">());</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">hunter</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">hunter</span><span class="o">.</span><span class="na">attach</span><span class="o">(</span><span class="n">action</span><span class="o">);</span>
      <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">service</span><span class="o">.</span><span class="na">isShutdown</span><span class="o">())</span> <span class="o">{</span>
      <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">hunter</span> <span class="o">=</span> <span class="n">forRequest</span><span class="o">(</span><span class="n">action</span><span class="o">.</span><span class="na">getPicasso</span><span class="o">(),</span> <span class="k">this</span><span class="o">,</span> <span class="n">cache</span><span class="o">,</span> <span class="n">stats</span><span class="o">,</span> <span class="n">action</span><span class="o">);</span>
    <span class="n">hunter</span><span class="o">.</span><span class="na">future</span> <span class="o">=</span> <span class="n">service</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">hunter</span><span class="o">);</span>
    <span class="n">hunterMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">action</span><span class="o">.</span><span class="na">getKey</span><span class="o">(),</span> <span class="n">hunter</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">dismissFailed</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">failedActions</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">action</span><span class="o">.</span><span class="na">getTarget</span><span class="o">());</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre>
</div>
<p>以上源码已删除日志相关部分，主要做以下任务：</p>

<ol>
  <li>若该<code class="highlighter-rouge">Action</code>对应的<code class="highlighter-rouge">tag</code>处于<code class="highlighter-rouge">pause</code>态，则将该<code class="highlighter-rouge">Action</code>添加到<code class="highlighter-rouge">pause</code>记录中；</li>
  <li>若该<code class="highlighter-rouge">Action</code>的<code class="highlighter-rouge">key</code>对应的<code class="highlighter-rouge">BitmapHunter</code>已存在，则将该任务附加到该<code class="highlighter-rouge">BitmapHunter</code>中等待执行，注意此处是用<code class="highlighter-rouge">Action</code>.<code class="highlighter-rouge">key</code>作为键存储<code class="highlighter-rouge">BitmapHunter</code>的，这表明<code class="highlighter-rouge">BitmapHunter</code>中所有<code class="highlighter-rouge">Action</code>请求的是同一个<code class="highlighter-rouge">Request</code>，即同一张图片，这也防止请求同一张图片的多个<code class="highlighter-rouge">Action</code>多次加载图片；</li>
  <li>若<code class="highlighter-rouge">PicassoExecutorService</code>已终止则放弃提交；</li>
  <li>生成新的<code class="highlighter-rouge">BitmapHunter</code>并提交到<code class="highlighter-rouge">PicassoExecutorService</code>执行，并记录该<code class="highlighter-rouge">BitmapHunter</code>；</li>
  <li>有必要的情况下，移除失败列表中的<code class="highlighter-rouge">Action</code>；</li>
</ol>

<h4 id="bitmaphunter">4. BitmapHunter执行任务</h4>
<p>提交到<code class="highlighter-rouge">PicassoExecutorService</code>的<code class="highlighter-rouge">BitmapHunter</code>被执行的时候会调用其<code class="highlighter-rouge">run</code>方法（非实际源码）：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">hunt</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">dispatcher</span><span class="o">.</span><span class="na">dispatchFailed</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="n">dispatcher</span><span class="o">.</span><span class="na">dispatchComplete</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">){</span>
    <span class="n">dispatcher</span><span class="o">.</span><span class="na">dispatchRetry</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="c1">// 或者</span>
    <span class="n">dispatcher</span><span class="o">.</span><span class="na">dispatchFailed</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
<span class="o">}</span>
</code></pre>
</div>
<p>调用<code class="highlighter-rouge">BitmapHunter.hunt</code>获取<code class="highlighter-rouge">Request</code>中<code class="highlighter-rouge">Uri</code>对应的资源图片，根据返回结果决定产生成功或失败事件，若抛出异常则根据异常类型决定是产生重试还是失败事件，具体细节可查看源码，这边主要分析<code class="highlighter-rouge">hunt</code>方法中的处理逻辑：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">Bitmap</span> <span class="nf">hunt</span><span class="p">(</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
    <span class="n">Bitmap</span> <span class="n">bitmap</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">shouldReadFromMemoryCache</span><span class="o">(</span><span class="n">memoryPolicy</span><span class="o">))</span> <span class="o">{</span>
      <span class="c1">// 当memoryPolicy未设定为NO_CACHE时，尝试从内存缓存中加载</span>
      <span class="n">bitmap</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">bitmap</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">stats</span><span class="o">.</span><span class="na">dispatchCacheHit</span><span class="o">();</span>
        <span class="n">loadedFrom</span> <span class="o">=</span> <span class="n">MEMORY</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">bitmap</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 内存缓存命中失败或不允许使用内存缓存则调用在创建BitmapHunter时选中的RequestHandler处理图片加载请求</span>
    <span class="n">data</span><span class="o">.</span><span class="na">networkPolicy</span> <span class="o">=</span> <span class="n">retryCount</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">NetworkPolicy</span><span class="o">.</span><span class="na">OFFLINE</span><span class="o">.</span><span class="na">index</span> <span class="o">:</span> <span class="n">networkPolicy</span><span class="o">;</span>
    <span class="n">RequestHandler</span><span class="o">.</span><span class="na">Result</span> <span class="n">result</span> <span class="o">=</span> <span class="n">requestHandler</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="n">networkPolicy</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">loadedFrom</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">getLoadedFrom</span><span class="o">();</span>
      <span class="c1">// 当图片为EXIF格式时会包含该参数</span>
      <span class="n">exifRotation</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">getExifOrientation</span><span class="o">();</span>
      <span class="n">bitmap</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">getBitmap</span><span class="o">();</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">bitmap</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">InputStream</span> <span class="n">is</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">getStream</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
          <span class="n">bitmap</span> <span class="o">=</span> <span class="n">decodeStream</span><span class="o">(</span><span class="n">is</span><span class="o">,</span> <span class="n">data</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
          <span class="n">Utils</span><span class="o">.</span><span class="na">closeQuietly</span><span class="o">(</span><span class="n">is</span><span class="o">);</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">bitmap</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">stats</span><span class="o">.</span><span class="na">dispatchBitmapDecoded</span><span class="o">(</span><span class="n">bitmap</span><span class="o">);</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">needsTransformation</span><span class="o">()</span> <span class="o">||</span> <span class="n">exifRotation</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">DECODE_LOCK</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">needsMatrixTransform</span><span class="o">()</span> <span class="o">||</span> <span class="n">exifRotation</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 利用Matrix实现图片的旋转、缩放等转换</span>
            <span class="n">bitmap</span> <span class="o">=</span> <span class="n">transformResult</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="n">bitmap</span><span class="o">,</span> <span class="n">exifRotation</span><span class="o">);</span>
          <span class="o">}</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">hasCustomTransformations</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// 依次应用图片加载Request中设定的图片转换器（Transformation.transform）</span>
            <span class="n">bitmap</span> <span class="o">=</span> <span class="n">applyCustomTransformations</span><span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">transformations</span><span class="o">,</span> <span class="n">bitmap</span><span class="o">);</span>
          <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">bitmap</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">stats</span><span class="o">.</span><span class="na">dispatchBitmapTransformed</span><span class="o">(</span><span class="n">bitmap</span><span class="o">);</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">bitmap</span><span class="o">;</span>
  <span class="o">}</span>
</code></pre>
</div>
<p>以上源码删除了日志部分，分析已注释在代码中。
其中<code class="highlighter-rouge">RequestHandler.load</code>的逻辑在前文中已有分析，后续会针对网络加载及缓存进行特别的分析。</p>

<h4 id="dispatchercompletefailretry">5. Dispatcher处理图片加载事件（complete、fail、retry）</h4>

<h5 id="performcompletebitmaphunter-hunter">performComplete(BitmapHunter hunter)</h5>
<div class="highlighter-rouge"><pre class="highlight"><code>    <span class="c1">// 如果memoryPolicy没有设定为NO_STORE则将该图片缓存到内存中</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">shouldWriteToMemoryCache</span><span class="o">(</span><span class="n">hunter</span><span class="o">.</span><span class="na">getMemoryPolicy</span><span class="o">()))</span> <span class="o">{</span>
      <span class="n">cache</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">hunter</span><span class="o">.</span><span class="na">getKey</span><span class="o">(),</span> <span class="n">hunter</span><span class="o">.</span><span class="na">getResult</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="c1">// 从记录中移除该BitmapHunter</span>
    <span class="n">hunterMap</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">hunter</span><span class="o">.</span><span class="na">getKey</span><span class="o">());</span>
    <span class="n">batch</span><span class="o">(</span><span class="n">hunter</span><span class="o">);</span>
</code></pre>
</div>
<p>其中<code class="highlighter-rouge">batch(hunter)</code>是将<code class="highlighter-rouge">BitmapHunter</code>作为参数生成事件（<code class="highlighter-rouge">HUNTER_BATCH_COMPLETE</code>）发送到主线程进行处理，这里有个小技巧就是这个事件是个延时事件，因此在图片加载任务比较密集的情况下可以减少事件的发送量。</p>

<h5 id="performerrorbitmaphunter-hunter-boolean-willreplay">performError(BitmapHunter hunter, boolean willReplay)</h5>
<div class="highlighter-rouge"><pre class="highlight"><code>    <span class="n">hunterMap</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">hunter</span><span class="o">.</span><span class="na">getKey</span><span class="o">());</span>
    <span class="n">batch</span><span class="o">(</span><span class="n">hunter</span><span class="o">);</span>
</code></pre>
</div>
<p>处理类似performComplete。</p>

<h5 id="performretrybitmaphunter-hunter">performRetry(BitmapHunter hunter)</h5>
<p>感觉文章有点长，而这部分源码又有些长，所以就不放源码的，主要处理为：</p>

<ol>
  <li>如果满足重试条件则将<code class="highlighter-rouge">BitmapHunter</code>重新提交到<code class="highlighter-rouge">PicassoExecutorService</code>进行执行；</li>
  <li>如果满足<code class="highlighter-rouge">replay</code>条件且没有提交重试，则将该<code class="highlighter-rouge">BitmapHunter</code>中的所有<code class="highlighter-rouge">Action</code>记录到<code class="highlighter-rouge">failedActions</code>并设置<code class="highlighter-rouge">Action</code>.<code class="highlighter-rouge">willReplay</code>，等待网络再次连接的时候进行重试；当然在<code class="highlighter-rouge">Action</code>被取消或重提交时会将该<code class="highlighter-rouge">Action从failedActions</code>中移除。</li>
</ol>

<h4 id="hunterbatchcomplete">6. 主线程处理HUNTER_BATCH_COMPLETE事件</h4>
<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">List</span><span class="o">&lt;</span><span class="n">BitmapHunter</span><span class="o">&gt;</span> <span class="n">batch</span> <span class="o">=</span> <span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">BitmapHunter</span><span class="o">&gt;)</span> <span class="n">msg</span><span class="o">.</span><span class="na">obj</span><span class="o">;</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">batch</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">BitmapHunter</span> <span class="n">hunter</span> <span class="o">=</span> <span class="n">batch</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
    <span class="n">hunter</span><span class="o">.</span><span class="na">picasso</span><span class="o">.</span><span class="na">complete</span><span class="o">(</span><span class="n">hunter</span><span class="o">);</span>
<span class="o">}</span>
</code></pre>
</div>
<p><code class="highlighter-rouge">Picasso.complete</code>方法将返回结果传递给<code class="highlighter-rouge">Action</code>的成功或失败回调，因此Action中的成功或失败回调是在UI主线程中调用的，因此执行刷新UI等操作。当BitmapHunter.exception不为空的时候回回调<code class="highlighter-rouge">Picasso.Listener.onImageLoadFailed</code>，个人觉得这个回调的实用性相对较低。</p>

<h4 id="picassocleanthread">7. Picasso中cleanThread的工作</h4>
<p><code class="highlighter-rouge">cleanThread</code>会循环检测是否有<code class="highlighter-rouge">Action</code>对应的<code class="highlighter-rouge">target</code>被回收，若有则发送<code class="highlighter-rouge">REQUEST_GCED</code>事件回收该<code class="highlighter-rouge">Action</code>，该事件调用<code class="highlighter-rouge">Picasso.cancelExistingRequest(action.getTarget())</code>进行处理：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    <span class="c1">// 仅在主线程中运行该函数</span>
    <span class="n">checkMain</span><span class="o">();</span>
    <span class="n">Action</span> <span class="n">action</span> <span class="o">=</span> <span class="n">targetToAction</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">action</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// 执行Action取消操作</span>
      <span class="n">action</span><span class="o">.</span><span class="na">cancel</span><span class="o">();</span>
      <span class="n">dispatcher</span><span class="o">.</span><span class="na">dispatchCancel</span><span class="o">(</span><span class="n">action</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">target</span> <span class="k">instanceof</span> <span class="n">ImageView</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// 如果当前Action被延迟加载则取消对应的延迟任务</span>
      <span class="n">ImageView</span> <span class="n">targetImageView</span> <span class="o">=</span> <span class="o">(</span><span class="n">ImageView</span><span class="o">)</span> <span class="n">target</span><span class="o">;</span>
      <span class="n">DeferredRequestCreator</span> <span class="n">deferredRequestCreator</span> <span class="o">=</span>
          <span class="n">targetToDeferredRequestCreator</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">targetImageView</span><span class="o">);</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">deferredRequestCreator</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">deferredRequestCreator</span><span class="o">.</span><span class="na">cancel</span><span class="o">();</span>
      <span class="o">}</span>
    <span class="o">}</span>
</code></pre>
</div>
<p>其中<code class="highlighter-rouge">Action</code>的取消工作由<code class="highlighter-rouge">Dispatcher</code>进行统一处理：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">performCancel</span><span class="p">(</span><span class="n">Action</span> <span class="n">action</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">action</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
    <span class="n">BitmapHunter</span> <span class="n">hunter</span> <span class="o">=</span> <span class="n">hunterMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">hunter</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// 将Action从对应的BitmapHunter清除</span>
      <span class="n">hunter</span><span class="o">.</span><span class="na">detach</span><span class="o">(</span><span class="n">action</span><span class="o">);</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">hunter</span><span class="o">.</span><span class="na">cancel</span><span class="o">())</span> <span class="o">{</span>
        <span class="c1">// 若该BitmapHunter无其他Action，则从任务记录中删除</span>
        <span class="n">hunterMap</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">pausedTags</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">action</span><span class="o">.</span><span class="na">getTag</span><span class="o">()))</span> <span class="o">{</span>
      <span class="c1">// 如果该Action对应tag当前是pause态，则从pausedActions中清除该Action</span>
      <span class="n">pausedActions</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">action</span><span class="o">.</span><span class="na">getTarget</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="c1">// 从replay的failedActions中清除该Action</span>
    <span class="n">failedActions</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">action</span><span class="o">.</span><span class="na">getTarget</span><span class="o">());</span>
<span class="o">}</span>
</code></pre>
</div>
<p>这样<code class="highlighter-rouge">Picasso</code>就可以有效管理<code class="highlighter-rouge">target</code>与<code class="highlighter-rouge">Action</code>之间的关系，防止无效加载浪费系统资源。其实<code class="highlighter-rouge">Target</code>也可以通过<code class="highlighter-rouge">Picasso</code>中的接口直接取消对对应的<code class="highlighter-rouge">Action</code>，其流程与<code class="highlighter-rouge">cleanThread</code>的清除流程一致。</p>

<h4 id="pausetagresumetag">8. <code class="highlighter-rouge">pauseTag</code>及<code class="highlighter-rouge">resumeTag</code></h4>
<p>既然说到这，索性先把Picasso中Action的管理体系说一下，Action个中有三种管理关系：</p>

<ol>
  <li><code class="highlighter-rouge">target</code>与<code class="highlighter-rouge">Action</code>：<code class="highlighter-rouge">target</code>是<code class="highlighter-rouge">Action</code>的承载体，如<code class="highlighter-rouge">ImageView</code>、<code class="highlighter-rouge">RemoteViews</code>或者继承自<code class="highlighter-rouge">Target</code>接口的实例，一个<code class="highlighter-rouge">target</code>仅对应一个<code class="highlighter-rouge">Action</code>，当基于某个<code class="highlighter-rouge">target</code>添加另一个<code class="highlighter-rouge">Action</code>是会清除掉之前对应的<code class="highlighter-rouge">Action</code>；</li>
  <li><code class="highlighter-rouge">tag</code>与<code class="highlighter-rouge">Action</code>：<code class="highlighter-rouge">tag</code>可以是普通字符串，也可以是<code class="highlighter-rouge">Android</code>中的组件（如<code class="highlighter-rouge">Activity</code>、<code class="highlighter-rouge">Fragment</code>等），一个<code class="highlighter-rouge">tag</code>对对应一组<code class="highlighter-rouge">Action</code>，可以通过<code class="highlighter-rouge">tag</code>取消、暂停或重新加载一组<code class="highlighter-rouge">Action</code>；</li>
  <li><code class="highlighter-rouge">key</code>与<code class="highlighter-rouge">Action</code>：<code class="highlighter-rouge">key</code>是根据<code class="highlighter-rouge">Request</code>创建的，用于表示请求的图片，并作为图片缓存的<code class="highlighter-rouge">key</code>，因此也唯一指向一个<code class="highlighter-rouge">BitmapHunter</code>，而<code class="highlighter-rouge">BitmapHunter</code>中可以包含一组请求这张图片的<code class="highlighter-rouge">Action</code>。</li>
</ol>

<p>理清楚这层关系之后，再来说<code class="highlighter-rouge">pauseTag</code>及<code class="highlighter-rouge">resumeTag</code>：  <br />
<code class="highlighter-rouge">pauseTag</code>就是讲<code class="highlighter-rouge">tag</code>对应的一组<code class="highlighter-rouge">Action</code>移除到<code class="highlighter-rouge">pausedActions</code>；<code class="highlighter-rouge">resumeTag</code>就是将<code class="highlighter-rouge">pausedActions</code>中所有<code class="highlighter-rouge">Action</code>重新提交执行（这里会先从缓存中<code class="highlighter-rouge">Action</code>对应的图片，如果命中则直接完成<code class="highlighter-rouge">Action</code>）。</p>

<hr />

<h5 id="picasso-1">至此，<code class="highlighter-rouge">Picasso</code>加载及缓存图片的整体流程就分析完毕了。</h5>

<hr />

<h3 id="section-5">四、其他想说的</h3>

<h4 id="utilsflushstacklocalleakslooper">1. Utils.flushStackLocalLeaks(Looper)</h4>
<div class="highlighter-rouge"><pre class="highlight"><code>  <span class="cm">/**
   * Prior to Android 5, HandlerThread always keeps a stack local reference to the last message
   * that was sent to it. This method makes sure that stack local reference never stays there
   * for too long by sending new messages to it every second.
   */</span>
  <span class="kd">static</span> <span class="kt">void</span> <span class="n">flushStackLocalLeaks</span><span class="o">(</span><span class="n">Looper</span> <span class="n">looper</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Handler</span> <span class="n">handler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Handler</span><span class="o">(</span><span class="n">looper</span><span class="o">)</span> <span class="o">{</span>
      <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">void</span> <span class="n">handleMessage</span><span class="o">(</span><span class="n">Message</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">sendMessageDelayed</span><span class="o">(</span><span class="n">obtainMessage</span><span class="o">(),</span> <span class="n">THREAD_LEAK_CLEANING_MS</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">};</span>
    <span class="n">handler</span><span class="o">.</span><span class="na">sendMessageDelayed</span><span class="o">(</span><span class="n">handler</span><span class="o">.</span><span class="na">obtainMessage</span><span class="o">(),</span> <span class="n">THREAD_LEAK_CLEANING_MS</span><span class="o">);</span>
  <span class="o">}</span>
</code></pre>
</div>
<p>意思就是5.0之前<code class="highlighter-rouge">HandlerThread</code>有个Bug，会保持最后一条消息的引用，用这种周期性空事件防止引用到重要资源导致内存泄露，至于怎么验证这个Bug，可以通过dump内存看，后续有时间再具体研究。</p>

<h4 id="okhttpdownloader">2. OkHttpDownloader</h4>
<p>这是一个基于<code class="highlighter-rouge">okhttp</code>的<code class="highlighter-rouge">downloader</code>，这不是我要说的重点，重点是：</p>

<blockquote>
  <p><strong>Square真乃业界良心，旗下开源的okhttp、retrofit、picasso、okio、otto、leakcanary、javapoet等等知名常用库，简直让感动得哭。</strong></p>
</blockquote>

<p>后续文章会分析<code class="highlighter-rouge">okhttp</code>，也为这边的磁盘缓存画上句号。</p>

            </div>
            
            <div id="disqus_thread" style="margin-top: 50px;">
                <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                <a href="http://disqus.com" class="dsq-brlink"><span class="logo-disqus">正在加载评论...</span></a>
            </div>
            
            </div>
          </div>
          <div class="pagination">
              
              
                <a class="btn btn-default" href="/2016/01/Handler%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90" class="previous">上一篇</a>
              
</div>

        </div>
        <div class="col-md-3 hidden-xs">
            <div style="min-height: 900px;">
<div class="sidebar well">
    <h1>最新文章</h1>
    <ul>
        
          <li><a href="/2016/03/Picasso%E8%AF%A6%E8%A7%A3">Picasso详解</a></li>
        
          <li><a href="/2016/01/Handler%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90">Handler运行机制分析</a></li>
        
          <li><a href="/2016/01/JUnit%E4%B9%8BMatcher">JUnit之Matcher</a></li>
        
          <li><a href="/2016/01/JUnit%E4%B9%8BAssertion">JUnit之Assertion</a></li>
        
          <li><a href="/2016/01/GitHub%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97">GitHub学习指南</a></li>
        
    </ul>
</div>

<div class="sidebar well">
<h1>相关链接</h1>
<ul>
  <li><a href="https://github.com/SparkInLee/HotPatch" target="blank">HotPatch</a></li>
</ul>

</div>
</div>

        </div>
    </div>
</div>


  <script type="text/javascript">
    var disqus_shortname = 'sparklee';

    var disqus_config = function () {
        this.page.identifier = '2016-03-picasso-e8-af-a6-e8-a7-a3';
    };

   (function() {
     var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
     dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
     (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>


<div class="container-fluid">
    <div class="row-fluid">
        <div class="span12 footer navbar-inverse navbar-fixed-bottom">
            <p class="copyright">&copy;2016 蒋黎的博客.</p>
        </div>
    </div>
</div>

<!-- 
  <script type="text/javascript">
    var disqus_shortname = 'sparklee';

    var disqus_config = function () {
        this.page.identifier = '2016-03-picasso-e8-af-a6-e8-a7-a3';
    };

   (function () {
     var s = document.createElement('script'); s.async = true;
     s.type = 'text/javascript';
     s.src = '//' + disqus_shortname + '.disqus.com/count.js';
     (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
   }());
 </script>

 -->

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-75606848-1', 'auto');
    ga('send', 'pageview');
  </script>



</body>
</html>

